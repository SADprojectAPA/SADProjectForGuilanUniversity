#  الگوهای Saga و Circuit Breaker

## مقدمه

این گزارش پیاده سازی و درک دو الگوی معماری حیاتی—الگوی Saga و الگوی Circuit Breaker—را در یک پلتفرم مدیریت دانشگاهی مبتنی بر میکروسرویس های توزیع شده مستند می کند. این پلتفرم شامل شش میکروسرویس مستقل است: سرویس احراز هویت، سرویس منابع، سرویس بازار، سرویس آموزش الکترونیکی، سرویس IoT و سرویس شاتل. این سرویس ها به صورت مستقل با پایگاه داده های خود کار می کنند و از طریق API Gateway، صف های پیام (RabbitMQ) و فراخوانی های مستقیم HTTP با یکدیگر ارتباط برقرار می کنند.

در یک معماری میکروسرویس توزیع شده، تراکنش های سنتی ACID که چندین سرویس را در بر می گیرند به دلیل نبود هماهنگ کننده تراکنش مشترک و نیاز به استقلال سرویس امکان پذیر نیستند. این محدودیت معماری نیاز به رویکردهای جایگزین برای حفظ سازگاری داده و انعطاف پذیری سیستم را ضروری می کند. الگوی Saga چالش تراکنش های توزیع شده را برطرف می کند، در حالی که الگوی Circuit Breaker تحمل خطا را فراهم کرده و از شکست های آبشاری در مرزهای سرویس جلوگیری می کند.

این گزارش توضیح می دهد که چرا این الگوها در سیستم های توزیع شده ضروری هستند، چگونه در این پروژه خاص پیاده سازی شده اند و در طول فرآیند پیاده سازی چه چیزهایی آموخته شده است.

---

## الگوی Saga: هدف و ضرورت

### درک چالش های تراکنش توزیع شده

در برنامه های یکپارچه، تراکنش ها می توانند با استفاده از ویژگی های ACID (اتمی بودن، سازگاری، جداسازی، دوام) در یک پایگاه داده واحد مدیریت شوند. با این حال، در یک معماری میکروسرویس، هر سرویس پایگاه داده خود را حفظ می کند و عملیاتی که نیاز به هماهنگی در چندین سرویس دارند نمی توانند به تراکنش های توزیع شده سنتی (مانند two-phase commit) به دلیل چندین محدودیت حیاتی تکیه کنند:

1. **سربار عملکردی**: تراکنش های توزیع شده به قفل گذاری در چندین سرویس نیاز دارند که منجر به کاهش قابل توجه عملکرد و بن بست های احتمالی می شود.

2. **استقلال سرویس**: میکروسرویس ها برای استقرار و مقیاس پذیری مستقل طراحی شده اند. اتصال محکم از طریق تراکنش های توزیع شده این اصل را نقض می کند.

3. **در دسترس بودن**: یک هماهنگ کننده تراکنش توزیع شده به یک نقطه شکست واحد تبدیل می شود. اگر هماهنگ کننده با شکست مواجه شود، همه تراکنش ها مسدود می شوند.

4. **مقیاس پذیری**: تراکنش های توزیع شده در سناریوهای با توان عملیاتی بالا به خوبی مقیاس پذیر نیستند، زیرا به سربار هماهنگی نیاز دارند که با افزایش تعداد سرویس های شرکت کننده افزایش می یابد.

### راه حل الگوی Saga

الگوی Saga که توسط Hector Garcia-Molina و Kenneth Salem در سال 1987 معرفی شد، مکانیزمی برای مدیریت تراکنش های توزیع شده بدون نیاز به قفل های توزیع شده یا هماهنگ کننده مرکزی فراهم می کند. به جای استفاده از تراکنش های ACID، Saga از یک دنباله از تراکنش های محلی استفاده می کند که هر کدام می توانند به صورت مستقل commit شوند. اگر هر مرحله ای با شکست مواجه شود، تراکنش های جبرانی (عملیات بازگشت) به ترتیب معکوس برای لغو اثرات مراحل تکمیل شده اجرا می شوند.

الگوی Saga مزایای متعددی ارائه می دهد:

- **بدون قفل های توزیع شده**: هر سرویس تراکنش های محلی را به صورت مستقل انجام می دهد و نیاز به مکانیزم های قفل گذاری توزیع شده را از بین می برد.

- **تحمل خطا**: الگو با اجرای منطق جبرانی برای مراحل تکمیل شده، شکست های جزئی را به خوبی مدیریت می کند.

- **مقیاس پذیری**: سرویس ها می توانند تراکنش ها را به صورت مستقل بدون سربار هماهنگی در طول اجرای عادی پردازش کنند.

- **سازگاری نهایی**: در حالی که سیستم ممکن است در طول جبران موقتاً ناسازگار باشد، در نهایت به یک حالت سازگار می رسد.

- **استقلال سرویس**: سرویس ها در حالی که در گردش های کاری توزیع شده شرکت می کنند، استقلال خود را حفظ می کنند.

### چرا Saga در این پروژه مورد نیاز است

در پلتفرم مدیریت دانشگاهی، جریان خرید از بازار نمونه ای از سناریویی است که نیاز به مدیریت تراکنش توزیع شده دارد. یک خرید شامل چندین مرحله در سرویس های مختلف است:

1. **رزرو موجودی** (سرویس بازار): کاهش تعداد بلیط موجود
2. **تأیید سفارش** (سرویس بازار): به روزرسانی وضعیت سفارش به تأیید شده
3. **پردازش پرداخت** (سرویس پرداخت): برداشت وجه از مشتری
4. **اعلان** (سرویس اعلان): ارسال تأیید خرید

اگر هر مرحله ای پس از موفقیت سایر مراحل با شکست مواجه شود، سیستم باید اطمینان حاصل کند که همه عملیات تکمیل شده برگشت داده می شوند تا سازگاری داده حفظ شود. به عنوان مثال، اگر پردازش پرداخت پس از رزرو موجودی با شکست مواجه شود، موجودی باید بازیابی شود تا از ناسازگاری موجودی جلوگیری شود. الگوی Saga مکانیزمی را برای هماهنگی این مراحل و تضمین اتمی بودن از طریق جبران فراهم می کند.

---

## پیاده سازی الگوی Saga در پروژه

### مرور معماری

پروژه یک **الگوی Saga مبتنی بر Orchestrator** را پیاده سازی می کند که در آن یک orchestrator مرکزی (کلاس `SagaOrchestrator`) اجرای همه مراحل در تراکنش را هماهنگ می کند. این رویکرد در مقایسه با رویکرد مبتنی بر choreography که در آن هر سرویس مرحله بعدی را تصمیم می گیرد، کنترل و دید بهتری ارائه می دهد.

### جزئیات پیاده سازی

پیاده سازی Saga در `services/marketplace-service/app/services/saga_service.py` قرار دارد و از سه جزء اصلی تشکیل شده است:

#### 1. کلاس SagaStep

کلاس `SagaStep` نشان دهنده یک مرحله واحد در تراکنش Saga است. هر مرحله شامل:
- **نام**: شناسه برای مرحله
- **تابع اجرا**: عملیاتی که باید انجام شود (عمل رو به جلو)
- **تابع جبران**: عملیات بازگشت برای لغو عمل رو به جلو
- **وضعیت**: حالت فعلی (PENDING، COMPLETED، FAILED، COMPENSATED)

```python
class SagaStep:
    def __init__(
        self,
        name: str,
        execute: Callable,
        compensate: Callable,
        service_url: str = None
    ):
        self.name = name
        self.execute = execute
        self.compensate = compensate
        self.status = SagaStepStatus.PENDING
```

#### 2. کلاس SagaOrchestrator

کلاس `SagaOrchestrator` اجرای تراکنش های Saga را مدیریت می کند. این کلاس یک رجیستری از saga های فعال را نگهداری کرده و اجرا و جبران مراحل را هماهنگ می کند.

**جریان اجرا**:
1. orchestrator لیستی از اشیاء `SagaStep` را دریافت می کند
2. یک `saga_id` منحصر به فرد برای ردیابی تولید می کند
3. مراحل به صورت متوالی به ترتیب مشخص شده اجرا می شوند
4. اگر هر مرحله ای با شکست مواجه شود، جبران برای همه مراحل قبلاً تکمیل شده فعال می شود
5. جبران به ترتیب معکوس اجرا می شود (LIFO - آخرین ورودی، اولین خروجی)

**متدهای کلیدی**:
- `execute_saga()`: همه مراحل را به صورت متوالی اجرا کرده و شکست ها را مدیریت می کند
- `_compensate()`: عملیات بازگشت را برای مراحل تکمیل شده انجام می دهد

#### 3. گردش کار Saga خرید

تابع `create_purchase_saga()` تراکنش Saga خاص برای خریدهای بازار را تعریف می کند. این تابع از چهار مرحله تشکیل شده است:

**مرحله 1: رزرو موجودی**
- **اجرا**: `available_quantity` بلیط را کاهش داده و در صورت رسیدن مقدار به صفر، وضعیت را به "sold" به روز می کند
- **جبران**: مقدار را بازیابی کرده و وضعیت را به "available" برمی گرداند

**مرحله 2: تأیید سفارش**
- **اجرا**: وضعیت سفارش را به `CONFIRMED` به روز کرده و `saga_id` را مرتبط می کند
- **جبران**: وضعیت سفارش را به `CANCELLED` تنظیم کرده و دلیل شکست را ثبت می کند

**مرحله 3: پردازش پرداخت**
- **اجرا**: سرویس پرداخت را (با استفاده از الگوی Strategy) برای برداشت وجه از مشتری فراخوانی می کند
- **جبران**: استرداد وجه را آغاز می کند (در محیط تولید، این با APIهای درگاه پرداخت یکپارچه می شود)

**مرحله 4: ارسال اعلان**
- **اجرا**: یک اعلان تأیید خرید ارسال می کند (عملیات غیرحیاتی)
- **جبران**: نیازی به جبران نیست (عملیات idempotent)

### یکپارچه سازی با سرویس بازار

Saga از endpoint مسیر `/marketplace/purchase` در `services/marketplace-service/app/routers/marketplace.py` فراخوانی می شود. جریان یکپارچه سازی به شرح زیر است:

1. کاربر درخواست خرید را آغاز می کند
2. سفارش با وضعیت `PENDING` ایجاد می شود
3. تراکنش Saga از طریق `create_purchase_saga()` اجرا می شود
4. در صورت موفقیت Saga: وضعیت سفارش به `COMPLETED` به روز می شود، آیتم های سبد خرید حذف می شوند، رویداد منتشر می شود
5. در صورت شکست Saga: وضعیت سفارش به `FAILED` به روز می شود، جبران اجرا می شود، رویداد شکست منتشر می شود

### تضمین های سازگاری

پیاده سازی از طریق موارد زیر سازگاری نهایی را تضمین می کند:

- **ردیابی شناسه Saga**: هر سفارش یک `saga_id` را ذخیره می کند که امکان ردیابی و audit trail را فراهم می کند
- **مدیریت وضعیت**: وضعیت سفارش حالت تراکنش را منعکس می کند (PENDING → CONFIRMED → COMPLETED یا FAILED)
- **منطق جبرانی**: هر مرحله توابع جبرانی idempotent را پیاده سازی می کند که می توانند به صورت ایمن retry شوند
- **مدیریت خطا**: شکست ها ثبت و لاگ می شوند و جبران به صورت خودکار اجرا می شود

### محدودیت ها و ملاحظات

پیاده سازی فعلی دارای محدودیت هایی است که باید در محیط تولید برطرف شوند:

1. **وضعیت در حافظه**: orchestrator saga های فعال را در حافظه نگهداری می کند که با restart سرویس از بین می روند. برای تولید، یک ذخیره ساز پایدار (پایگاه داده یا صف پیام) مورد نیاز است.

2. **شکست های جبرانی**: اگر خود جبران با شکست مواجه شود، سیستم یک هشدار لاگ می کند اما retry نمی کند. یک پیاده سازی قوی تر شامل مکانیزم های retry و صف های dead-letter خواهد بود.

3. **مدیریت timeout**: پیاده سازی شامل مکانیزم های timeout برای مراحل طولانی نیست.

4. **نظارت**: در حالی که `saga_id` امکان ردیابی را فراهم می کند، نظارت و مشاهده پذیری جامع نیاز به یکپارچه سازی با سیستم های ردیابی توزیع شده دارد.

---

## الگوی Circuit Breaker: هدف و ضرورت

### درک شکست های آبشاری

در سیستم های توزیع شده، سرویس ها از طریق ارتباط همزمان یا ناهمزمان به یکدیگر وابسته هستند. زمانی که یک سرویس downstream در دسترس نباشد، کند شود یا شروع به بازگشت خطا کند، سرویس های upstream که به آن وابسته هستند می توانند با چندین مشکل مواجه شوند:

1. **اتمام منابع**: اگر یک سرویس به درخواست های خود به یک سرویس در حال شکست ادامه دهد، thread ها، اتصالات یا حافظه می توانند در حالی که منتظر timeout ها هستند تمام شوند.

2. **شکست های آبشاری**: شکست یک سرویس می تواند به سرویس های وابسته منتقل شود و به طور بالقوه کل سیستم را متوقف کند.

3. **کاهش کیفیت تجربه کاربر**: عملیات حیاتی ممکن است توسط وابستگی های غیرحیاتی مسدود شوند و باعث تأخیرها یا شکست های غیرضروری شوند.

4. **تقویت**: یک سرویس در حال شکست می تواند باعث شکست چندین سرویس upstream شود و تأثیر شکست اولیه را تقویت کند.

### راه حل الگوی Circuit Breaker

الگوی Circuit Breaker که از قطع کننده های برق الهام گرفته شده، با نظارت بر سلامت یک سرویس و توقف خودکار درخواست ها زمانی که سرویس در حال شکست است، از شکست های آبشاری جلوگیری می کند. این الگو در سه حالت کار می کند:

1. **CLOSED**: عملیات عادی. درخواست ها مجاز هستند و شکست ها شمارش می شوند.

2. **OPEN**: مدار پس از یک آستانه از شکست ها "قطع" می شود. درخواست ها بلافاصله بدون فراخوانی سرویس در حال شکست رد می شوند و به آن زمان برای بازیابی می دهند.

3. **HALF_OPEN**: پس از یک دوره timeout، مدار تعداد محدودی درخواست آزمایشی را برای تعیین بازیابی سرویس اجازه می دهد. در صورت موفقیت، به CLOSED منتقل می شود؛ در غیر این صورت، به OPEN برمی گردد.

الگوی Circuit Breaker موارد زیر را فراهم می کند:

- **شکست سریع**: درخواست ها زمانی که مدار باز است بلافاصله شکست می خورند و از timeout های طولانی جلوگیری می کنند
- **جداسازی خطا**: شکست ها به سرویس در حال شکست محدود می شوند و آبشاری نمی شوند
- **بازیابی خودکار**: مدار به طور خودکار بازیابی سرویس را بدون دخالت دستی آزمایش می کند
- **حفاظت از منابع**: با توقف درخواست ها به سرویس های در حال شکست از اتمام منابع جلوگیری می کند
- **کاهش کیفیت تدریجی**: عملیات غیرحیاتی می توانند بدون مسدود کردن عملکرد حیاتی شکست بخورند

### چرا Circuit Breaker در این پروژه مورد نیاز است

در سرویس آموزش الکترونیکی، زمانی که یک آزمون شروع می شود، سیستم تلاش می کند یک اعلان برای دانشجویان ارسال کند. سرویس اعلان یک وابستگی غیرحیاتی است—اگر شکست بخورد، آزمون همچنان باید بتواند شروع شود. با این حال، بدون حفاظت:

1. اگر سرویس اعلان در دسترس نباشد، هر درخواست شروع آزمون منتظر یک timeout (مثلاً 30 ثانیه) خواهد ماند و عملیات شروع آزمون را مسدود می کند.

2. اگر سرویس اعلان کند باشد، می تواند باعث انباشت درخواست های شروع آزمون شود و عملکرد سیستم را کاهش دهد.

3. اگر سرویس اعلان شروع به شکست متناوب کند، این شکست ها می توانند به سرویس آموزش الکترونیکی منتقل شوند و به طور بالقوه بر عملکرد آزمون تأثیر بگذارند.

الگوی Circuit Breaker تضمین می کند که شکست های اعلان بر عملیات حیاتی شروع آزمون تأثیر نمی گذارند و به سیستم اجازه می دهد با رد اعلان ها زمانی که سرویس در دسترس نیست، به صورت تدریجی کیفیت را کاهش دهد.

---

## پیاده سازی الگوی Circuit Breaker در پروژه

### مرور معماری

پیاده سازی Circuit Breaker به عنوان یک ابزار قابل استفاده مجدد در `shared/circuit_breaker.py` ارائه شده و برای همه سرویس ها در دسترس است. سرویس آموزش الکترونیکی از این پیاده سازی برای محافظت از فراخوانی ها به سرویس اعلان استفاده می کند.

### جزئیات پیاده سازی

#### 1. Enum CircuitState

circuit breaker در سه حالت کار می کند که به عنوان enum تعریف شده اند:

```python
class CircuitState(str, Enum):
    CLOSED = "closed"      # عملیات عادی
    OPEN = "open"          # در حال شکست، رد درخواست ها
    HALF_OPEN = "half_open" # آزمایش بازیابی سرویس
```

#### 2. کلاس CircuitBreaker

کلاس `CircuitBreaker` منطق اصلی را با پارامترهای قابل پیکربندی زیر پیاده سازی می کند:

- **failure_threshold**: تعداد شکست های متوالی قبل از باز کردن مدار (پیش فرض: 5)
- **timeout**: زمان به ثانیه قبل از تلاش برای بستن مدار (پیش فرض: 60.0)
- **expected_exception**: نوع استثنایی که باید گرفته و به عنوان شکست شمارش شود (پیش فرض: Exception)

**مدیریت حالت**:
- `failure_count` و `last_failure_time` را ردیابی می کند
- `success_count` را برای اعتبارسنجی حالت half-open نگهداری می کند
- به `half_open_success_threshold` (پیش فرض: 2) فراخوانی موفق برای بستن از half-open نیاز دارد

**متدهای کلیدی**:
- `call()`: wrapper همزمان برای فراخوانی های تابع
- `call_async()`: wrapper ناهمزمان برای فراخوانی های تابع async
- `_on_success()`: فراخوانی های موفق و انتقال های حالت را مدیریت می کند
- `_on_failure()`: شکست ها را مدیریت کرده و زمانی که آستانه رسید مدار را باز می کند
- `_should_attempt_reset()`: تعیین می کند آیا زمان کافی برای آزمایش بازیابی گذشته است یا خیر

**منطق انتقال حالت**:
- **CLOSED → OPEN**: زمانی که `failure_count >= failure_threshold`
- **OPEN → HALF_OPEN**: پس از گذشت `timeout` ثانیه
- **HALF_OPEN → CLOSED**: پس از `half_open_success_threshold` موفقیت متوالی
- **HALF_OPEN → OPEN**: در صورت هر شکستی در حالت half-open

#### 3. الگوی Decorator

پیاده سازی شامل یک تابع `circuit_breaker_decorator()` است که امکان اعمال circuit breaker به عنوان decorator به توابع را فراهم می کند و استفاده را ساده می کند:

```python
@circuit_breaker_decorator(failure_threshold=5, timeout=60.0)
async def my_function():
    # تابع محافظت شده
    pass
```

### یکپارچه سازی با سرویس آموزش الکترونیکی

Circuit Breaker در `services/e-learning-service/app/services/notification_service.py` برای محافظت از فراخوانی های اعلان استفاده می شود.

#### جریان پیاده سازی

1. **نمونه Circuit Breaker**: یک نمونه سراسری `notification_circuit_breaker` با آستانه های مناسب ایجاد می شود.

2. **تابع محافظت شده**: تابع `send_exam_start_notification()` فراخوانی واقعی اعلان را در یک تابع داخلی محافظت شده `_send_notification()` می پیچد.

3. **فراخوانی Circuit Breaker**: تابع داخلی از طریق `circuit_breaker.call_async()` اجرا می شود که:
   - قبل از اجرا حالت مدار را بررسی می کند
   - در صورتی که مدار CLOSED یا HALF_OPEN باشد تابع را اجرا می کند
   - اگر مدار OPEN باشد بلافاصله یک استثنا ایجاد می کند (مگر اینکه timeout گذشته باشد)
   - حالت را بر اساس موفقیت یا شکست به روز می کند

4. **مدیریت خطا**: اگر مدار باز باشد یا فراخوانی شکست بخورد، تابع یک پاسخ شکست برمی گرداند اما استثنایی ایجاد نمی کند و به عملیات شروع آزمون اجازه ادامه می دهد.

#### مثال استفاده

```python
async def send_exam_start_notification(student_id, exam_id, exam_title):
    async def _send_notification():
        # فراخوانی واقعی HTTP به سرویس اعلان
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.post(...)
            return response.json()
    
    try:
        result = await notification_circuit_breaker.call_async(_send_notification)
        return {"success": True, "circuit_state": "closed", "result": result}
    except Exception as e:
        # مدار باز یا سرویس شکست خورد - غیرحیاتی، لاگ و ادامه
        return {"success": False, "circuit_state": "open", "error": str(e)}
```

### مزایا در عمل

پیاده سازی چندین مزیت عملی را نشان می دهد:

1. **عملیات غیرمسدودکننده**: درخواست های شروع آزمون حتی زمانی که سرویس اعلان در دسترس نیست بلافاصله تکمیل می شوند، زیرا circuit breaker درخواست ها را بدون انتظار برای timeout ها رد می کند.

2. **بازیابی خودکار**: زمانی که سرویس اعلان بازیابی می شود، circuit breaker به طور خودکار از طریق HALF_OPEN به CLOSED منتقل می شود و عملیات عادی را بدون دخالت دستی از سر می گیرد.

3. **مشاهده پذیری**: حالت مدار در اشیاء پاسخ گنجانده شده است که امکان نظارت و سیستم های هشدار برای ردیابی سلامت سرویس را فراهم می کند.

4. **کاهش کیفیت تدریجی**: سیستم با عملکرد کاهش یافته (بدون اعلان) به کار خود ادامه می دهد به جای اینکه به طور کامل شکست بخورد.

### ملاحظات پیکربندی

پیاده سازی فعلی از آستانه های پیش فرض استفاده می کند، اما در تولید، این ها باید بر اساس موارد زیر تنظیم شوند:

- **ویژگی های سرویس**: سرویس های حیاتی ممکن است به آستانه های شکست پایین تری نیاز داشته باشند
- **زمان بازیابی**: سرویس هایی با زمان بازیابی طولانی تر ممکن است به timeout های طولانی تری نیاز داشته باشند
- **الگوهای ترافیک**: سرویس های با ترافیک بالا ممکن است به آستانه های متفاوتی برای جلوگیری از مثبت های کاذب نیاز داشته باشند
- **الزامات کسب وکار**: نرخ شکست قابل قبول و زمان بازیابی باید در پیکربندی اطلاع رسانی شوند

---

## تأمل: یادگیری و بینش ها

### درک چالش های سیستم های توزیع شده

پیاده سازی الگوهای Saga و Circuit Breaker بینش های عمیقی در مورد پیچیدگی های سیستم های توزیع شده فراهم کرد. مهم ترین یادگیری درک این موضوع بود که چرا رویکردهای سنتی مدیریت تراکنش در معماری های میکروسرویس شکست می خورند و چگونه الگوهای جایگزین این محدودیت ها را برطرف می کنند.

**بینش های الگوی Saga**:

1. **پیچیدگی جبران**: پیاده سازی منطق جبرانی پیچیده تر از آن چیزی است که در ابتدا به نظر می رسد. هر عملیات رو به جلو باید یک جبران متناظر داشته باشد که idempotent باشد و بتواند شکست های جزئی را مدیریت کند. به عنوان مثال، بازیابی مقدار موجودی باید موارد خاصی مانند بلیط هایی که زمانی که مقدار به صفر رسید به عنوان "sold" علامت گذاری شدند را در نظر بگیرد.

2. **مدیریت حالت**: ردیابی حالت Saga و اطمینان از سازگاری نیاز به طراحی دقیق دارد. استفاده از `saga_id` برای همبستگی و وضعیت سفارش برای نمایش حالت برای اشکال زدایی و نظارت ضروری بود.

3. **Orchestrator در مقابل Choreography**: رویکرد orchestrator کنترل و دید بهتری ارائه می دهد، اما یک جزء مرکزی معرفی می کند که می تواند به یک گلوگاه تبدیل شود. درک تعادل ها بین این رویکردها برای تصمیمات معماری حیاتی است.

4. **سازگاری نهایی**: پذیرش سازگاری نهایی یک تغییر پارادایم از تراکنش های سنتی ACID بود. سیستم می تواند در طول جبران موقتاً ناسازگار باشد که نیاز به مدیریت دقیق در رابط کاربری و منطق کسب وکار دارد.

**بینش های الگوی Circuit Breaker**:

1. **تنظیم آستانه**: تعیین آستانه های شکست و مقادیر timeout مناسب نیاز به درک ویژگی های شکست سرویس دارد. آستانه بسیار پایین باعث مثبت های کاذب می شود، در حالی که آستانه بسیار بالا اجازه می دهد شکست های بسیار زیادی قبل از فعال شدن حفاظت رخ دهند.

2. **اهمیت حالت Half-Open**: حالت half-open برای بازیابی خودکار حیاتی است. بدون آن، مدار برای بسته شدن به دخالت دستی نیاز خواهد داشت که در سیستم های تولید غیرعملی است.

3. **وابستگی های غیرحیاتی**: شناسایی اینکه کدام وابستگی ها حیاتی در مقابل غیرحیاتی هستند ضروری است. Circuit Breaker برای وابستگی های غیرحیاتی که کاهش کیفیت تدریجی قابل قبول است بیشترین ارزش را دارد.

4. **مشاهده پذیری**: حالت circuit breaker سیگنال های مشاهده پذیری ارزشمندی ارائه می دهد. نظارت بر انتقال های حالت مدار می تواند به شناسایی مشکلات سلامت سرویس قبل از اینکه حیاتی شوند کمک کند.

### چالش های پیاده سازی

چندین چالش در طول پیاده سازی با آن ها مواجه شد:

1. **مدیریت خطا**: تمایز بین انواع مختلف شکست ها (timeout ها، خطاهای اتصال، خطاهای برنامه) و مدیریت مناسب آن ها نیاز به توجه دقیق داشت.

2. **پیچیدگی Async/Await**: پیاده سازی circuit breaker برای هر دو تابع همزمان و ناهمزمان نیاز به درک مدل async/await پایتون و مدیریت coroutine داشت.

3. **تست**: تست رفتار circuit breaker، به خصوص انتقال های حالت و منطق timeout، نیاز به طراحی دقیق تست برای شبیه سازی سناریوهای مختلف شکست داشت.

4. **یکپارچه سازی**: یکپارچه سازی الگوها با کد سرویس موجود در حالی که جداسازی نگرانی ها را حفظ می کرد نیاز به refactoring و طراحی دقیق داشت.

### بهترین شیوه های آموخته شده

از طریق پیاده سازی، چندین بهترین شیوه ظاهر شدند:

1. **Idempotency**: همه عملیات جبرانی و فراخوانی های محافظت شده توسط circuit breaker باید idempotent باشند تا retry ها را به صورت ایمن مدیریت کنند.

2. **لاگ گیری و نظارت**: لاگ گیری جامع از اجرای Saga و انتقال های حالت circuit breaker برای اشکال زدایی و عملیات ضروری است.

3. **پیکربندی**: قابل پیکربندی کردن آستانه ها و timeout ها امکان تنظیم بدون تغییرات کد را فراهم می کند که برای سیستم های تولید حیاتی است.

4. **جداسازی نگرانی ها**: نگهداری پیاده سازی های الگو در ابزارهای مشترک استفاده مجدد و سازگاری را در سرویس ها ترویج می کند.

5. **کاهش کیفیت تدریجی**: طراحی سیستم ها برای ادامه عملیات با عملکرد کاهش یافته زمانی که وابستگی ها شکست می خورند انعطاف پذیری کلی سیستم را بهبود می بخشد.

### بهبودهای آینده

پیاده سازی حوزه هایی را برای بهبود آینده آشکار کرد:

1. **پایداری**: حالت Saga باید برای بقا از restart های سرویس پایدار شود، احتمالاً با استفاده از پایگاه داده یا صف پیام.

2. **ردیابی توزیع شده**: یکپارچه سازی با سیستم های ردیابی توزیع شده (مثل OpenTelemetry) دید بهتری در اجرای Saga در سرویس ها فراهم می کند.

3. **مکانیزم های Retry**: افزودن backoff نمایی و منطق retry برای شکست های گذرا انعطاف پذیری را بهبود می بخشد.

4. **معیارها و هشدار**: معیارهای circuit breaker (نرخ شکست، فرکانس انتقال حالت) باید برای نظارت و هشدار در معرض دید قرار گیرند.

5. **Timeout های Saga**: پیاده سازی timeout ها برای مراحل فردی Saga از مسدود شدن نامحدود منابع توسط تراکنش های طولانی جلوگیری می کند.

### نتیجه گیری

پیاده سازی الگوهای Saga و Circuit Breaker در این پلتفرم مدیریت دانشگاهی تجربه عملی با الگوهای سیستم های توزیع شده را فراهم کرد که برای ساخت معماری های میکروسرویس انعطاف پذیر و مقیاس پذیر ضروری هستند. این الگوها چالش های اساسی در سیستم های توزیع شده را برطرف می کنند: حفظ سازگاری در مرزهای سرویس و جلوگیری از شکست های آبشاری.

الگوی Saga تراکنش های پیچیده توزیع شده را بدون سربار قفل های توزیع شده امکان پذیر می کند، در حالی که الگوی Circuit Breaker سیستم ها را از شکست های آبشاری محافظت کرده و کاهش کیفیت تدریجی را امکان پذیر می کند. هر دو الگو ابزارهای ضروری در جعبه ابزار معمار میکروسرویس هستند و درک پیاده سازی، تعادل ها و بهترین شیوه های آن ها برای ساخت سیستم های توزیع شده آماده تولید حیاتی است.

فرآیند یادگیری این نکته را برجسته کرد که سیستم های توزیع شده نیاز به طرز فکر متفاوتی نسبت به برنامه های یکپارچه دارند، پذیرش سازگاری نهایی، طراحی برای شکست و اولویت دهی به انعطاف پذیری نسبت به سازگاری کامل. این بینش ها برای توسعه سیستم های توزیع شده آینده ارزشمند خواهند بود.
 